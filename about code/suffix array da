#include<iostream>
#include<cstdio>
#include<cstring>
#define INF 0x3f3f3f3f
using namespace std;
const int Maxn = 2e5+5;
int sa[Maxn];
int t1[Maxn];
int t2[Maxn];
int c[Maxn];
int _rank[Maxn];
int height[Maxn];
int num[Maxn];
bool cmp(int *r, int a, int b, int l)
{
    return r[a] == r[b] && r[a + l] == r[b + l];
}
void da(int str[], int sa[], int rank[], int height[], int n, int m)
{
    n++;
    int i, j, p, *x = t1, *y = t2;  //  第一轮基数排序,如果s的最大值很大,可改为快速排序
    for (i = 0; i < m; i++)
    {
        c[i] = 0;
    }
    for (i = 0; i < n; i++)
    {
        c[x[i] = str[i]]++;
    }
    for (i = 1; i < m; i++)
    {
        c[i] += c[i-1];
    }
    for (i = n - 1; i >= 0; i--)
    {
        sa[--c[x[i]]] = i;
    }
    for (j = 1; j <= n; j <<= 1)
    {
        p = 0;
        //  直接利用sa数组排序第二关键字
        for (i = n - j; i < n; i++)
        {
            y[p++] = i;                 //  后面的j个数第二关键字为空的最小
        }
        for (i = 0; i < n; i++)
        {
            if (sa[i] >= j)
            {
                y[p++] = sa[i] - j;     //  这样数组y保存的就是按照第二关键字排序的结果
            }
        }
        //  基数排序第一关键字
        for (i = 0; i < m; i++)
        {
            c[i] = 0;
        }
        for (i = 0; i < n; i++)
        {
            c[x[y[i]]]++;
        }
        for (i = 1; i < m; i++)
        {
            c[i] += c[i - 1];
        }
        for (i = n - 1; i >= 0; i--)
        {
            sa[--c[x[y[i]]]] = y[i];    //  根据sa和x数组计算新的x数组
        }
        swap(x, y);
        p = 1;
        x[sa[0]] = 0;
        for (i = 1; i < n; i++)
        {
            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;
        }
        if (p >= n)
        {
            break;
        }
        m = p;                          //  下次基数排序的最大值
    }
    int k = 0;
    n--;
    for (i = 0; i <= n; i++)
    {
        rank[sa[i]] = i;
    }
    for (i = 0; i < n; i++)
    {
        if (k)
        {
            k--;
        }
        j = sa[rank[i] - 1];
        while (str[i + k] == str[j + k])
        {
            k++;
        }
        height[rank[i]] = k;
    }
}
//bool cmp(int *r,int a,int b,int l)
//{
//	return r[a]==r[b] && r[a+l]==r[b+l];
//}
//void da(int str[],int sa[],int rank[],int height[],int n,int m)
//{
//	n++;
//	int i,j,p,*x=t1,*y=t2;
//	for(i = 0;i<m;i++) c[i]=0;
//	for(i = 0;i<n;i++) c[x[i]=str[i]]++;
//	for(i = 1;i<m;i++) c[i]+=c[i-1];
//	for(i = n-1;i>=0;i--) sa[--c[x[i]]]=i;
//	for(j = 1;j <=n;j<<=1)
//	{
//		p = 0;
//		for(i = n-j;i<n;i++) y[p++]=i;
//		for(i = 0;i<n;i++)
//		{
//			if(sa[i]>=j) y[p++]=sa[i]-j;
//		}
//		for(i = 0;i<m;i++) c[i]=0;
//		for(i = 0;i<n;i++) c[x[y[i]]]++;
//		for(i = 1;i<m;i++) c[i]+=c[i-1];
//		for(i =n-1;i>=0;i--) sa[--c[x[y[i]]]]=y[i];
//		swap(x,y);
//		p = 1;
//		x[sa[0]]=0;
//		for(i = 1;i<n;i++) x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
//		if(p>=n) break;
//		m = p;
//	}
//	int k = 0;
//	n--;
//	for(i = 0;i<=n;i++) rank[sa[i]]=i;
//	for(i = 0;i<n;i++) 
//	{
//		if(k) k--;
//		j = sa[rank[i]-1];
//		while(str[i+k]==str[j+k]) k++;
//		height[rank[i]]=k;
//	}
//}
int input[Maxn];
int n;
bool check(int k)
{
	int mx=-INF,mn=INF;
	for(int i=0;i<=n;i++)
	{
		if(height[i]>=k)
		{
			mx = max(mx,sa[i]);
			mn = min(mn,sa[i]);
			if(mx-mn>=k) return true;
		}
		else
		{
			mx=mn=sa[i];
		}
	}
	return false;
}
int main()
{
	while(~scanf("%d",&n) && n)
	{
		int Max=0;
		for(int i=0;i<n;i++) scanf("%d",&input[i]);
		for(int i=0;i<n-1;i++) num[i]=input[i+1]-input[i]+100,Max=max(Max,num[i]);
		n--;
		num[n]=0; 
		da(num,sa,_rank,height,n,Max+1);
		int l=1,r=n;
		int mid;
		int ans = 0;
		while(l<=r)
		{
			int mid = (l+r)/2;
			if(check(mid))
			{
				ans = max(ans,mid+1);
				l = mid+1;
			}
			else
			{
				r = mid - 1;
			}
		}
		if(ans<5) printf("0\n");
		else printf("%d\n",ans);
	}
}
